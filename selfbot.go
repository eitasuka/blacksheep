/*
Copyright 2019 tira

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
 * selfbot.go contains the main funtions of the self bot.
 */
package main

import (
	"bufio"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"strings"

	"github.com/bwmarrin/discordgo"
)

var (
	customCommands = make(map[string]string)
)

func Selfbot(Discord *discordgo.Session) {
	ParseCustomCommands()
	Discord.AddHandler(OnMessageCreate)
	err := Discord.Open()
	if err != nil {
		Fatal("Failed to start selfbot, " + err.Error())
	}
	fmt.Println("Using prefix", UserConfig.SelfBotCopypastas)
	fmt.Println("Type `exit` to exit")
	fmt.Println("Listening for messages")
	exitScanner := bufio.NewScanner(os.Stdin)
	for exitScanner.Scan() {
		if exitScanner.Text() == "exit" {
			os.Exit(0)
		}
	}
}

func ParseCustomCommands() {
	commandsFile := configFolder + "commands.json"
	if _, err := os.Stat(commandsFile); os.IsNotExist(err) {
		file, err := os.Create(commandsFile)
		if err != nil {
			Fatal("Failed to create commands.json: " + err.Error())
		}
		file.Close()
	}
	data, err := ioutil.ReadFile(commandsFile)
	if err != nil {
		Fatal("Failed to open commands.json " + err.Error())
	}
	err = json.Unmarshal(data, &customCommands)
	if err != nil {
		Fatal("Failed to parse commands.json " + err.Error())
	}
}

func OnMessageCreate(Discord *discordgo.Session,
	message *discordgo.MessageCreate) {
	if message.Author.ID != Discord.State.User.ID ||
		!strings.HasPrefix(message.Content, UserConfig.SelfBotPrefix) {
		/*
		 * Quickly ignore all messages not send by the bot owner, and messages that
		 * don't start with the bot's identifier.
		 */
		return
	}
	command := strings.Split(
		message.Content[len(UserConfig.SelfBotPrefix):len(message.Content)], " ")[0]
	messageContent := message.Content[len(UserConfig.SelfBotPrefix)+
		len(command) : len(message.Content)]
	newMessage := discordgo.NewMessageEdit(message.ChannelID, message.ID)
	switch {
	case command == "about":
		/*
		 * We only want to display the embed here, so we empty out the message
		 * "content".
		 */
		newMessage.SetContent("")
		newMessage.SetEmbed(&discordgo.MessageEmbed{
			URL:         "https://github.com/t1ra/blacksheep",
			Title:       "Blacksheep",
			Description: "The Discord tooling powerhouse.",
			Color:       0xff00ba, /* A beautiful pink :) */
		})
	case command == "help":
		newMessage.SetContent("")
		newMessage.SetEmbed(&discordgo.MessageEmbed{
			Title:       "Blacksheep",
			Description: "Help",
			Color:       0xff00ba,
			Fields:      HelpFields(),
		})
	case command == "huge":
		newMessage.SetContent(Huge(messageContent))
	case command == "copypasta":
		newMessage.SetContent(Copypasta(UserConfig.SelfBotCopypastas))
	case command == "command":
		switch strings.Split(messageContent, " ")[0] {
		case "list":
			newMessage.SetContent("")
			newMessage.SetEmbed(&discordgo.MessageEmbed{
				Title:       "Custom Commands",
				Description: "Your custom commands",
				Color:       0xff00ba,
				Fields:      CustomCommands(customCommands),
			})
		case "new":
			NewCustomCommand(messageContent[4:len(messageContent)])
		}
	}
	/*
	 * Edit the message containing the command, replacing its contents with
	 * whatever was generated by the switch.
	 */
	Discord.ChannelMessageEditComplex(newMessage)
}
